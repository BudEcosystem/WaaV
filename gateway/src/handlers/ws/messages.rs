//! WebSocket message types and routing
//!
//! This module defines all message types for WebSocket communication,
//! including incoming and outgoing messages, unified message structures,
//! and message routing for optimized throughput.

use bytes::Bytes;
use serde::{Deserialize, Serialize};

/// Maximum allowed size for TTS text in Speak messages (100 KB)
/// Prevents memory exhaustion from oversized text payloads
pub const MAX_SPEAK_TEXT_SIZE: usize = 100 * 1024;

/// Maximum allowed size for message content in SendMessage (50 KB)
/// Prevents abuse via large data payloads
pub const MAX_MESSAGE_CONTENT_SIZE: usize = 50 * 1024;

/// Maximum allowed size for SIP transfer_to field (256 bytes)
/// Phone numbers should never exceed this
pub const MAX_SIP_TRANSFER_TO_SIZE: usize = 256;

use super::config::{
    LiveKitWebSocketConfig, STTWebSocketConfig, TTSWebSocketConfig, default_allow_interruption,
    default_audio_enabled,
};

/// WebSocket message types for incoming messages
#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
#[allow(clippy::large_enum_variant)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub enum IncomingMessage {
    #[serde(rename = "config")]
    Config {
        /// Optional unique identifier for this WebSocket session.
        /// Used for recording paths and session tracking.
        /// If not provided, a UUID v4 will be auto-generated by the server.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[cfg_attr(
            feature = "openapi",
            schema(example = "550e8400-e29b-41d4-a716-446655440000")
        )]
        stream_id: Option<String>,
        /// Enable audio processing (STT/TTS). Defaults to true if not specified.
        #[serde(
            default = "default_audio_enabled",
            skip_serializing_if = "Option::is_none"
        )]
        audio: Option<bool>,
        /// STT configuration (required only when audio=true)
        #[serde(skip_serializing_if = "Option::is_none")]
        stt_config: Option<STTWebSocketConfig>,
        /// TTS configuration (required only when audio=true)
        #[serde(skip_serializing_if = "Option::is_none")]
        tts_config: Option<TTSWebSocketConfig>,
        /// Optional LiveKit configuration for real-time audio streaming
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit: Option<LiveKitWebSocketConfig>,
    },
    #[serde(rename = "speak")]
    Speak {
        /// Text to synthesize
        text: String,
        /// Flush TTS buffer immediately
        #[serde(skip_serializing_if = "Option::is_none")]
        flush: Option<bool>,
        /// Allow this TTS to be interrupted
        #[serde(
            default = "default_allow_interruption",
            skip_serializing_if = "Option::is_none"
        )]
        allow_interruption: Option<bool>,
    },
    #[serde(rename = "clear")]
    Clear,
    #[serde(rename = "send_message")]
    SendMessage {
        /// Message content
        message: String,
        /// Message role (e.g., "user", "assistant")
        role: String,
        /// Optional topic/channel
        #[serde(skip_serializing_if = "Option::is_none")]
        topic: Option<String>,
        /// Optional debug metadata
        #[serde(skip_serializing_if = "Option::is_none")]
        debug: Option<serde_json::Value>,
    },
    /// Transfer the current SIP call to another phone number.
    ///
    /// This command initiates a SIP REFER transfer for the current participant
    /// in the LiveKit room. The participant identity and room name are derived
    /// from the WebSocket connection state.
    #[serde(rename = "sip_transfer")]
    SIPTransfer {
        /// The destination phone number to transfer the call to.
        ///
        /// Accepts phone numbers in various formats:
        /// - International format with `+` prefix (e.g., "+1234567890")
        /// - National format without prefix (e.g., "1234567890")
        /// - Internal extensions (e.g., "1234")
        ///
        /// Validation is performed by the handler, not during deserialization.
        #[cfg_attr(feature = "openapi", schema(example = "+1234567890"))]
        transfer_to: String,
    },
}

/// Unified message structure for all incoming messages from various sources
#[derive(Debug, Serialize, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct UnifiedMessage {
    /// Text message content (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Binary data encoded as base64 (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// Participant/sender identity
    pub identity: String,
    /// Topic/channel for the message
    pub topic: String,
    /// Room/space identifier
    pub room: String,
    /// Timestamp when the message was received
    pub timestamp: u64,
}

/// Participant disconnection information
#[derive(Debug, Serialize, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct ParticipantDisconnectedInfo {
    /// Participant's unique identity
    pub identity: String,
    /// Participant's display name (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Room identifier
    pub room: String,
    /// Timestamp when the disconnection occurred
    pub timestamp: u64,
}

/// WebSocket message types for outgoing messages
#[derive(Debug, Serialize)]
#[serde(tag = "type")]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub enum OutgoingMessage {
    #[serde(rename = "ready")]
    Ready {
        /// Unique identifier for this WebSocket session.
        /// Either provided by the client in config or auto-generated by server (UUID v4).
        #[cfg_attr(
            feature = "openapi",
            schema(example = "550e8400-e29b-41d4-a716-446655440000")
        )]
        stream_id: String,
        /// Optional LiveKit room name that was created
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit_room_name: Option<String>,
        /// Optional LiveKit URL to connect to
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit_url: Option<String>,
        /// Optional identity of the AI agent participant in the room
        #[serde(skip_serializing_if = "Option::is_none")]
        waav_participant_identity: Option<String>,
        /// Optional display name of the AI agent participant
        #[serde(skip_serializing_if = "Option::is_none")]
        waav_participant_name: Option<String>,
    },
    #[serde(rename = "stt_result")]
    STTResult {
        /// Transcribed text
        transcript: String,
        /// Whether this is the final version of the transcript
        is_final: bool,
        /// Whether speech has ended
        is_speech_final: bool,
        /// Confidence score (0.0 to 1.0)
        confidence: f32,
    },
    #[serde(rename = "message")]
    Message {
        /// Unified message structure containing text/data from various sources
        message: UnifiedMessage,
    },
    #[serde(rename = "participant_disconnected")]
    ParticipantDisconnected {
        /// Information about the participant who disconnected
        participant: ParticipantDisconnectedInfo,
    },
    /// TTS playback completion notification
    #[serde(rename = "tts_playback_complete")]
    TTSPlaybackComplete {
        /// Timestamp when completion occurred (milliseconds since epoch)
        timestamp: u64,
    },
    #[serde(rename = "error")]
    Error {
        /// Error message
        message: String,
    },
    /// SIP transfer specific error
    ///
    /// This message is sent when a SIP transfer operation fails.
    /// Clients can subscribe to this specific error type to handle
    /// SIP transfer failures separately from other errors.
    #[serde(rename = "sip_transfer_error")]
    SIPTransferError {
        /// Error message describing why the transfer failed
        message: String,
    },
}

/// Message routing for optimized throughput
/// Using enum for zero-cost abstraction
pub enum MessageRoute {
    Outgoing(OutgoingMessage),
    Binary(Bytes),
    Close,
}

/// Error type for message validation failures
#[derive(Debug, Clone)]
pub enum MessageValidationError {
    /// TTS text exceeds maximum allowed size
    SpeakTextTooLarge { size: usize, max: usize },
    /// SendMessage content exceeds maximum allowed size
    MessageContentTooLarge { size: usize, max: usize },
    /// SIP transfer_to field exceeds maximum allowed size
    SipTransferToTooLarge { size: usize, max: usize },
}

impl std::fmt::Display for MessageValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::SpeakTextTooLarge { size, max } => {
                write!(f, "Speak text too large: {} bytes (max: {} bytes)", size, max)
            }
            Self::MessageContentTooLarge { size, max } => {
                write!(f, "Message content too large: {} bytes (max: {} bytes)", size, max)
            }
            Self::SipTransferToTooLarge { size, max } => {
                write!(f, "SIP transfer_to too large: {} bytes (max: {} bytes)", size, max)
            }
        }
    }
}

impl std::error::Error for MessageValidationError {}

impl IncomingMessage {
    /// Validates message field sizes to prevent resource exhaustion attacks.
    ///
    /// # Returns
    /// * `Ok(())` if all fields are within size limits
    /// * `Err(MessageValidationError)` if any field exceeds its limit
    ///
    /// # Limits
    /// * Speak text: 100 KB
    /// * SendMessage message: 50 KB
    /// * SIP transfer_to: 256 bytes
    pub fn validate_size(&self) -> Result<(), MessageValidationError> {
        match self {
            IncomingMessage::Speak { text, .. } => {
                let size = text.len();
                if size > MAX_SPEAK_TEXT_SIZE {
                    return Err(MessageValidationError::SpeakTextTooLarge {
                        size,
                        max: MAX_SPEAK_TEXT_SIZE,
                    });
                }
            }
            IncomingMessage::SendMessage { message, .. } => {
                let size = message.len();
                if size > MAX_MESSAGE_CONTENT_SIZE {
                    return Err(MessageValidationError::MessageContentTooLarge {
                        size,
                        max: MAX_MESSAGE_CONTENT_SIZE,
                    });
                }
            }
            IncomingMessage::SIPTransfer { transfer_to } => {
                let size = transfer_to.len();
                if size > MAX_SIP_TRANSFER_TO_SIZE {
                    return Err(MessageValidationError::SipTransferToTooLarge {
                        size,
                        max: MAX_SIP_TRANSFER_TO_SIZE,
                    });
                }
            }
            // Config and Clear don't have user-provided text content that needs size limits
            IncomingMessage::Config { .. } | IncomingMessage::Clear => {}
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;
    use uuid::Uuid;

    #[test]
    fn test_ready_message_serialization_full() {
        let ready = OutgoingMessage::Ready {
            stream_id: "test-stream-123".to_string(),
            livekit_room_name: Some("room-456".to_string()),
            livekit_url: Some("ws://localhost:7880".to_string()),
            waav_participant_identity: Some("waav-ai".to_string()),
            waav_participant_name: Some("WaaV AI".to_string()),
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(r#""stream_id":"test-stream-123""#));
        assert!(json.contains(r#""type":"ready""#));
        assert!(json.contains(r#""livekit_room_name":"room-456""#));
    }

    #[test]
    fn test_ready_message_serialization_minimal() {
        let ready = OutgoingMessage::Ready {
            stream_id: "minimal-stream".to_string(),
            livekit_room_name: None,
            livekit_url: None,
            waav_participant_identity: None,
            waav_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(r#""stream_id":"minimal-stream""#));
        assert!(json.contains(r#""type":"ready""#));
        assert!(!json.contains("livekit_room_name"));
        assert!(!json.contains("livekit_url"));
        assert!(!json.contains("waav_participant_identity"));
        assert!(!json.contains("waav_participant_name"));
    }

    #[test]
    fn test_ready_message_with_uuid_stream_id() {
        let uuid = Uuid::new_v4().to_string();

        let ready = OutgoingMessage::Ready {
            stream_id: uuid.clone(),
            livekit_room_name: None,
            livekit_url: None,
            waav_participant_identity: None,
            waav_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(&uuid));
    }

    #[test]
    fn test_ready_message_stream_id_position() {
        let ready = OutgoingMessage::Ready {
            stream_id: "first-field".to_string(),
            livekit_room_name: Some("room".to_string()),
            livekit_url: None,
            waav_participant_identity: None,
            waav_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        let stream_id_pos = json.find("stream_id").expect("stream_id should exist");
        let room_pos = json
            .find("livekit_room_name")
            .expect("livekit_room_name should exist");

        assert!(
            stream_id_pos < room_pos,
            "stream_id should appear before livekit_room_name in JSON"
        );
    }

    #[test]
    fn test_sip_transfer_message_deserialization() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "+1234567890"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "+1234567890");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_without_plus_prefix() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "1234567890"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "1234567890");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_internal_extension() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "1234"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "1234");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_serialization() {
        let msg = IncomingMessage::SIPTransfer {
            transfer_to: "+1234567890".to_string(),
        };

        let json = serde_json::to_string(&msg).expect("Should serialize");
        assert!(json.contains(r#""type":"sip_transfer""#));
        assert!(json.contains(r#""transfer_to":"+1234567890""#));
    }

    #[test]
    fn test_sip_transfer_missing_field() {
        let json = r#"{"type": "sip_transfer"}"#;
        let result: Result<IncomingMessage, _> = serde_json::from_str(json);
        assert!(result.is_err(), "Should fail without transfer_to field");
    }

    #[test]
    fn test_sip_transfer_empty_transfer_to() {
        // Empty string is valid at deserialization time - validation happens later
        let json = r#"{"type": "sip_transfer", "transfer_to": ""}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_with_whitespace() {
        // Whitespace is preserved at deserialization - trimming happens in validation
        let json = r#"{"type": "sip_transfer", "transfer_to": "  +1234567890  "}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "  +1234567890  ");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_error_serialization() {
        let error = OutgoingMessage::SIPTransferError {
            message: "Invalid phone number".to_string(),
        };

        let json = serde_json::to_string(&error).expect("Should serialize");
        assert!(json.contains(r#""type":"sip_transfer_error""#));
        assert!(json.contains(r#""message":"Invalid phone number""#));
    }

    // ============== Message Size Validation Tests ==============

    #[test]
    fn test_speak_text_within_limit() {
        let text = "a".repeat(MAX_SPEAK_TEXT_SIZE);
        let msg = IncomingMessage::Speak {
            text,
            flush: None,
            allow_interruption: None,
        };
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_speak_text_exceeds_limit() {
        let text = "a".repeat(MAX_SPEAK_TEXT_SIZE + 1);
        let msg = IncomingMessage::Speak {
            text,
            flush: None,
            allow_interruption: None,
        };
        let err = msg.validate_size().unwrap_err();
        match err {
            MessageValidationError::SpeakTextTooLarge { size, max } => {
                assert_eq!(size, MAX_SPEAK_TEXT_SIZE + 1);
                assert_eq!(max, MAX_SPEAK_TEXT_SIZE);
            }
            _ => panic!("Expected SpeakTextTooLarge error"),
        }
    }

    #[test]
    fn test_send_message_within_limit() {
        let message = "b".repeat(MAX_MESSAGE_CONTENT_SIZE);
        let msg = IncomingMessage::SendMessage {
            message,
            role: "user".to_string(),
            topic: None,
            debug: None,
        };
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_send_message_exceeds_limit() {
        let message = "b".repeat(MAX_MESSAGE_CONTENT_SIZE + 1);
        let msg = IncomingMessage::SendMessage {
            message,
            role: "user".to_string(),
            topic: None,
            debug: None,
        };
        let err = msg.validate_size().unwrap_err();
        match err {
            MessageValidationError::MessageContentTooLarge { size, max } => {
                assert_eq!(size, MAX_MESSAGE_CONTENT_SIZE + 1);
                assert_eq!(max, MAX_MESSAGE_CONTENT_SIZE);
            }
            _ => panic!("Expected MessageContentTooLarge error"),
        }
    }

    #[test]
    fn test_sip_transfer_within_limit() {
        let transfer_to = "+".to_string() + &"1".repeat(MAX_SIP_TRANSFER_TO_SIZE - 1);
        let msg = IncomingMessage::SIPTransfer { transfer_to };
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_sip_transfer_exceeds_limit() {
        let transfer_to = "1".repeat(MAX_SIP_TRANSFER_TO_SIZE + 1);
        let msg = IncomingMessage::SIPTransfer { transfer_to };
        let err = msg.validate_size().unwrap_err();
        match err {
            MessageValidationError::SipTransferToTooLarge { size, max } => {
                assert_eq!(size, MAX_SIP_TRANSFER_TO_SIZE + 1);
                assert_eq!(max, MAX_SIP_TRANSFER_TO_SIZE);
            }
            _ => panic!("Expected SipTransferToTooLarge error"),
        }
    }

    #[test]
    fn test_config_message_validation_passes() {
        let msg = IncomingMessage::Config {
            stream_id: Some("test".to_string()),
            audio: Some(true),
            stt_config: None,
            tts_config: None,
            livekit: None,
        };
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_clear_message_validation_passes() {
        let msg = IncomingMessage::Clear;
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_validation_error_display() {
        let err = MessageValidationError::SpeakTextTooLarge {
            size: 150000,
            max: 102400,
        };
        let display = format!("{}", err);
        assert!(display.contains("150000"));
        assert!(display.contains("102400"));
        assert!(display.contains("Speak text too large"));
    }
}
