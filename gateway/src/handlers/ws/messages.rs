//! WebSocket message types and routing
//!
//! This module defines all message types for WebSocket communication,
//! including incoming and outgoing messages, unified message structures,
//! and message routing for optimized throughput.

use bytes::Bytes;
use serde::{Deserialize, Serialize};

/// Maximum allowed size for TTS text in Speak messages (100 KB)
/// Prevents memory exhaustion from oversized text payloads
pub const MAX_SPEAK_TEXT_SIZE: usize = 100 * 1024;

/// Maximum allowed size for message content in SendMessage (50 KB)
/// Prevents abuse via large data payloads
pub const MAX_MESSAGE_CONTENT_SIZE: usize = 50 * 1024;

/// Maximum allowed size for SIP transfer_to field (256 bytes)
/// Phone numbers should never exceed this
pub const MAX_SIP_TRANSFER_TO_SIZE: usize = 256;

/// Maximum allowed size for stream_id field (256 bytes)
/// UUID format is 36 chars, allow extra buffer for custom IDs
pub const MAX_STREAM_ID_SIZE: usize = 256;

/// Maximum allowed size for auth token (4 KB)
/// JWTs and API keys should not exceed this
pub const MAX_AUTH_TOKEN_SIZE: usize = 4 * 1024;

use super::config::{
    LiveKitWebSocketConfig, STTWebSocketConfig, TTSWebSocketConfig, default_allow_interruption,
    default_audio_enabled,
};

/// WebSocket message types for incoming messages
#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
#[allow(clippy::large_enum_variant)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub enum IncomingMessage {
    #[serde(rename = "config")]
    Config {
        /// Optional unique identifier for this WebSocket session.
        /// Used for recording paths and session tracking.
        /// If not provided, a UUID v4 will be auto-generated by the server.
        #[serde(skip_serializing_if = "Option::is_none")]
        #[cfg_attr(
            feature = "openapi",
            schema(example = "550e8400-e29b-41d4-a716-446655440000")
        )]
        stream_id: Option<String>,
        /// Enable audio processing (STT/TTS). Defaults to true if not specified.
        #[serde(
            default = "default_audio_enabled",
            skip_serializing_if = "Option::is_none"
        )]
        audio: Option<bool>,
        /// DEPRECATED: Use `audio: false` instead. This field is for backward compatibility.
        /// When `audio_disabled: true` is sent, it's equivalent to `audio: false`.
        /// If both fields are present, `audio` takes precedence.
        #[serde(skip_serializing_if = "Option::is_none")]
        audio_disabled: Option<bool>,
        /// STT configuration (required only when audio=true)
        #[serde(skip_serializing_if = "Option::is_none")]
        stt_config: Option<STTWebSocketConfig>,
        /// TTS configuration (required only when audio=true)
        #[serde(skip_serializing_if = "Option::is_none")]
        tts_config: Option<TTSWebSocketConfig>,
        /// Optional LiveKit configuration for real-time audio streaming
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit: Option<LiveKitWebSocketConfig>,
    },
    #[serde(rename = "speak")]
    Speak {
        /// Text to synthesize
        text: String,
        /// Flush TTS buffer immediately
        #[serde(skip_serializing_if = "Option::is_none")]
        flush: Option<bool>,
        /// Allow this TTS to be interrupted
        #[serde(
            default = "default_allow_interruption",
            skip_serializing_if = "Option::is_none"
        )]
        allow_interruption: Option<bool>,
    },
    #[serde(rename = "clear")]
    Clear,
    #[serde(rename = "send_message")]
    SendMessage {
        /// Message content
        message: String,
        /// Message role (e.g., "user", "assistant")
        role: String,
        /// Optional topic/channel
        #[serde(skip_serializing_if = "Option::is_none")]
        topic: Option<String>,
        /// Optional debug metadata
        #[serde(skip_serializing_if = "Option::is_none")]
        debug: Option<serde_json::Value>,
    },
    /// Transfer the current SIP call to another phone number.
    ///
    /// This command initiates a SIP REFER transfer for the current participant
    /// in the LiveKit room. The participant identity and room name are derived
    /// from the WebSocket connection state.
    #[serde(rename = "sip_transfer")]
    SIPTransfer {
        /// The destination phone number to transfer the call to.
        ///
        /// Accepts phone numbers in various formats:
        /// - International format with `+` prefix (e.g., "+1234567890")
        /// - National format without prefix (e.g., "1234567890")
        /// - Internal extensions (e.g., "1234")
        ///
        /// Validation is performed by the handler, not during deserialization.
        #[cfg_attr(feature = "openapi", schema(example = "+1234567890"))]
        transfer_to: String,
    },
    /// Browser-friendly authentication message.
    ///
    /// This message type allows browser clients to authenticate after the WebSocket
    /// connection is established, since browsers cannot set custom headers during
    /// the WebSocket handshake. This must be the first message sent when using
    /// first-message authentication.
    ///
    /// # Authentication Flow
    /// 1. Client connects to `/ws` without Authorization header or query token
    /// 2. Server accepts connection with pending auth state
    /// 3. Client sends `{"type": "auth", "token": "<bearer_token>"}` as first message
    /// 4. Server validates token and either:
    ///    - Sends `{"type": "authenticated"}` on success
    ///    - Closes connection with 4001 code on failure
    ///
    /// # Example
    /// ```json
    /// {"type": "auth", "token": "sk_test_my_api_key"}
    /// ```
    #[serde(rename = "auth")]
    Auth {
        /// Bearer token for authentication.
        /// This should be the same token format as used in the Authorization header.
        #[cfg_attr(feature = "openapi", schema(example = "sk_test_my_api_key_123456"))]
        token: String,
    },
    /// Custom message type for plugin-defined message handlers.
    ///
    /// This variant allows plugins to define and handle their own message types
    /// without modifying the core gateway code. Plugins register handlers for
    /// specific message types, and the gateway routes messages accordingly.
    ///
    /// # Example
    /// ```json
    /// {"type": "custom", "message_type": "my_plugin_action", "payload": {"key": "value"}}
    /// ```
    #[serde(rename = "custom")]
    Custom {
        /// The plugin-defined message type identifier.
        /// This is used to look up the appropriate handler in the plugin registry.
        #[cfg_attr(feature = "openapi", schema(example = "analytics_event"))]
        message_type: String,
        /// The message payload as arbitrary JSON.
        /// The plugin handler is responsible for parsing and validating this.
        #[cfg_attr(feature = "openapi", schema(value_type = Object))]
        payload: serde_json::Value,
    },
}

/// Unified message structure for all incoming messages from various sources
#[derive(Debug, Serialize, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct UnifiedMessage {
    /// Text message content (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Binary data encoded as base64 (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    /// Participant/sender identity
    pub identity: String,
    /// Topic/channel for the message
    pub topic: String,
    /// Room/space identifier
    pub room: String,
    /// Timestamp when the message was received
    pub timestamp: u64,
}

/// Participant disconnection information
#[derive(Debug, Serialize, Clone)]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub struct ParticipantDisconnectedInfo {
    /// Participant's unique identity
    pub identity: String,
    /// Participant's display name (if available)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Room identifier
    pub room: String,
    /// Timestamp when the disconnection occurred
    pub timestamp: u64,
}

/// WebSocket message types for outgoing messages
#[derive(Debug, Serialize)]
#[serde(tag = "type")]
#[cfg_attr(feature = "openapi", derive(utoipa::ToSchema))]
pub enum OutgoingMessage {
    #[serde(rename = "ready")]
    Ready {
        /// Unique identifier for this WebSocket session.
        /// Either provided by the client in config or auto-generated by server (UUID v4).
        #[cfg_attr(
            feature = "openapi",
            schema(example = "550e8400-e29b-41d4-a716-446655440000")
        )]
        stream_id: String,
        /// Optional LiveKit room name that was created
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit_room_name: Option<String>,
        /// Optional LiveKit URL to connect to
        #[serde(skip_serializing_if = "Option::is_none")]
        livekit_url: Option<String>,
        /// Optional identity of the AI agent participant in the room
        #[serde(skip_serializing_if = "Option::is_none")]
        waav_participant_identity: Option<String>,
        /// Optional display name of the AI agent participant
        #[serde(skip_serializing_if = "Option::is_none")]
        waav_participant_name: Option<String>,
    },
    #[serde(rename = "stt_result")]
    STTResult {
        /// Transcribed text
        transcript: String,
        /// Whether this is the final version of the transcript
        is_final: bool,
        /// Whether speech has ended
        is_speech_final: bool,
        /// Confidence score (0.0 to 1.0)
        confidence: f32,
    },
    #[serde(rename = "message")]
    Message {
        /// Unified message structure containing text/data from various sources
        message: UnifiedMessage,
    },
    #[serde(rename = "participant_disconnected")]
    ParticipantDisconnected {
        /// Information about the participant who disconnected
        participant: ParticipantDisconnectedInfo,
    },
    /// TTS playback completion notification
    #[serde(rename = "tts_playback_complete")]
    TTSPlaybackComplete {
        /// Timestamp when completion occurred (milliseconds since epoch)
        timestamp: u64,
    },
    #[serde(rename = "error")]
    Error {
        /// Error message
        message: String,
    },
    /// SIP transfer specific error
    ///
    /// This message is sent when a SIP transfer operation fails.
    /// Clients can subscribe to this specific error type to handle
    /// SIP transfer failures separately from other errors.
    #[serde(rename = "sip_transfer_error")]
    SIPTransferError {
        /// Error message describing why the transfer failed
        message: String,
    },
    /// Authentication success response
    ///
    /// Sent after successful first-message authentication to confirm
    /// the client is now authenticated and can proceed with other commands.
    #[serde(rename = "authenticated")]
    Authenticated {
        /// The authenticated identity (API key ID or user ID from JWT)
        #[serde(skip_serializing_if = "Option::is_none")]
        id: Option<String>,
    },
    /// Authentication required notification
    ///
    /// Sent immediately after connection when authentication is required
    /// but no token was provided via header or query parameter.
    /// Client must send an `auth` message before any other commands.
    #[serde(rename = "auth_required")]
    AuthRequired,
    /// Plugin response message
    ///
    /// Generic response from a plugin handler for custom messages.
    /// Contains the message type for client routing and arbitrary JSON payload.
    #[serde(rename = "plugin_response")]
    PluginResponse {
        /// The message type this is a response to
        message_type: String,
        /// Response payload from the plugin
        payload: serde_json::Value,
    },
}

/// Message routing for optimized throughput
/// Using enum for zero-cost abstraction
pub enum MessageRoute {
    Outgoing(OutgoingMessage),
    Binary(Bytes),
    Close,
}

/// Error type for message validation failures
#[derive(Debug, Clone)]
pub enum MessageValidationError {
    /// TTS text exceeds maximum allowed size
    SpeakTextTooLarge { size: usize, max: usize },
    /// SendMessage content exceeds maximum allowed size
    MessageContentTooLarge { size: usize, max: usize },
    /// SIP transfer_to field exceeds maximum allowed size
    SipTransferToTooLarge { size: usize, max: usize },
    /// Stream ID exceeds maximum allowed size
    StreamIdTooLarge { size: usize, max: usize },
    /// Auth token exceeds maximum allowed size
    AuthTokenTooLarge { size: usize, max: usize },
}

impl std::fmt::Display for MessageValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::SpeakTextTooLarge { size, max } => {
                write!(
                    f,
                    "Speak text too large: {} bytes (max: {} bytes)",
                    size, max
                )
            }
            Self::MessageContentTooLarge { size, max } => {
                write!(
                    f,
                    "Message content too large: {} bytes (max: {} bytes)",
                    size, max
                )
            }
            Self::SipTransferToTooLarge { size, max } => {
                write!(
                    f,
                    "SIP transfer_to too large: {} bytes (max: {} bytes)",
                    size, max
                )
            }
            Self::StreamIdTooLarge { size, max } => {
                write!(
                    f,
                    "Stream ID too large: {} bytes (max: {} bytes)",
                    size, max
                )
            }
            Self::AuthTokenTooLarge { size, max } => {
                write!(
                    f,
                    "Auth token too large: {} bytes (max: {} bytes)",
                    size, max
                )
            }
        }
    }
}

impl std::error::Error for MessageValidationError {}

impl IncomingMessage {
    /// Validates message field sizes to prevent resource exhaustion attacks.
    ///
    /// # Returns
    /// * `Ok(())` if all fields are within size limits
    /// * `Err(MessageValidationError)` if any field exceeds its limit
    ///
    /// # Limits
    /// * Speak text: 100 KB
    /// * SendMessage message: 50 KB
    /// * SIP transfer_to: 256 bytes
    pub fn validate_size(&self) -> Result<(), MessageValidationError> {
        match self {
            IncomingMessage::Speak { text, .. } => {
                let size = text.len();
                if size > MAX_SPEAK_TEXT_SIZE {
                    return Err(MessageValidationError::SpeakTextTooLarge {
                        size,
                        max: MAX_SPEAK_TEXT_SIZE,
                    });
                }
            }
            IncomingMessage::SendMessage { message, .. } => {
                let size = message.len();
                if size > MAX_MESSAGE_CONTENT_SIZE {
                    return Err(MessageValidationError::MessageContentTooLarge {
                        size,
                        max: MAX_MESSAGE_CONTENT_SIZE,
                    });
                }
            }
            IncomingMessage::SIPTransfer { transfer_to } => {
                let size = transfer_to.len();
                if size > MAX_SIP_TRANSFER_TO_SIZE {
                    return Err(MessageValidationError::SipTransferToTooLarge {
                        size,
                        max: MAX_SIP_TRANSFER_TO_SIZE,
                    });
                }
            }
            IncomingMessage::Config { stream_id, .. } => {
                // Validate stream_id if provided
                if let Some(id) = stream_id {
                    let size = id.len();
                    if size > MAX_STREAM_ID_SIZE {
                        return Err(MessageValidationError::StreamIdTooLarge {
                            size,
                            max: MAX_STREAM_ID_SIZE,
                        });
                    }
                }
            }
            IncomingMessage::Auth { token } => {
                // Validate auth token length
                let size = token.len();
                if size > MAX_AUTH_TOKEN_SIZE {
                    return Err(MessageValidationError::AuthTokenTooLarge {
                        size,
                        max: MAX_AUTH_TOKEN_SIZE,
                    });
                }
            }
            IncomingMessage::Clear => {}
            IncomingMessage::Custom {
                message_type,
                payload,
            } => {
                // Validate message_type length (same limit as stream_id)
                if message_type.len() > MAX_STREAM_ID_SIZE {
                    return Err(MessageValidationError::StreamIdTooLarge {
                        size: message_type.len(),
                        max: MAX_STREAM_ID_SIZE,
                    });
                }
                // Validate serialized payload size
                let payload_str = payload.to_string();
                if payload_str.len() > MAX_MESSAGE_CONTENT_SIZE {
                    return Err(MessageValidationError::MessageContentTooLarge {
                        size: payload_str.len(),
                        max: MAX_MESSAGE_CONTENT_SIZE,
                    });
                }
            }
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;
    use uuid::Uuid;

    #[test]
    fn test_ready_message_serialization_full() {
        let ready = OutgoingMessage::Ready {
            stream_id: "test-stream-123".to_string(),
            livekit_room_name: Some("room-456".to_string()),
            livekit_url: Some("ws://localhost:7880".to_string()),
            waav_participant_identity: Some("waav-ai".to_string()),
            waav_participant_name: Some("WaaV AI".to_string()),
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(r#""stream_id":"test-stream-123""#));
        assert!(json.contains(r#""type":"ready""#));
        assert!(json.contains(r#""livekit_room_name":"room-456""#));
    }

    #[test]
    fn test_ready_message_serialization_minimal() {
        let ready = OutgoingMessage::Ready {
            stream_id: "minimal-stream".to_string(),
            livekit_room_name: None,
            livekit_url: None,
            waav_participant_identity: None,
            waav_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(r#""stream_id":"minimal-stream""#));
        assert!(json.contains(r#""type":"ready""#));
        assert!(!json.contains("livekit_room_name"));
        assert!(!json.contains("livekit_url"));
        assert!(!json.contains("waav_participant_identity"));
        assert!(!json.contains("waav_participant_name"));
    }

    #[test]
    fn test_ready_message_with_uuid_stream_id() {
        let uuid = Uuid::new_v4().to_string();

        let ready = OutgoingMessage::Ready {
            stream_id: uuid.clone(),
            livekit_room_name: None,
            livekit_url: None,
            waav_participant_identity: None,
            waav_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        assert!(json.contains(&uuid));
    }

    #[test]
    fn test_ready_message_stream_id_position() {
        let ready = OutgoingMessage::Ready {
            stream_id: "first-field".to_string(),
            livekit_room_name: Some("room".to_string()),
            livekit_url: None,
            waav_participant_identity: None,
            waav_participant_name: None,
        };

        let json = serde_json::to_string(&ready).expect("Should serialize");

        let stream_id_pos = json.find("stream_id").expect("stream_id should exist");
        let room_pos = json
            .find("livekit_room_name")
            .expect("livekit_room_name should exist");

        assert!(
            stream_id_pos < room_pos,
            "stream_id should appear before livekit_room_name in JSON"
        );
    }

    #[test]
    fn test_sip_transfer_message_deserialization() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "+1234567890"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "+1234567890");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_without_plus_prefix() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "1234567890"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "1234567890");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_internal_extension() {
        let json = r#"{"type": "sip_transfer", "transfer_to": "1234"}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "1234");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_message_serialization() {
        let msg = IncomingMessage::SIPTransfer {
            transfer_to: "+1234567890".to_string(),
        };

        let json = serde_json::to_string(&msg).expect("Should serialize");
        assert!(json.contains(r#""type":"sip_transfer""#));
        assert!(json.contains(r#""transfer_to":"+1234567890""#));
    }

    #[test]
    fn test_sip_transfer_missing_field() {
        let json = r#"{"type": "sip_transfer"}"#;
        let result: Result<IncomingMessage, _> = serde_json::from_str(json);
        assert!(result.is_err(), "Should fail without transfer_to field");
    }

    #[test]
    fn test_sip_transfer_empty_transfer_to() {
        // Empty string is valid at deserialization time - validation happens later
        let json = r#"{"type": "sip_transfer", "transfer_to": ""}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_with_whitespace() {
        // Whitespace is preserved at deserialization - trimming happens in validation
        let json = r#"{"type": "sip_transfer", "transfer_to": "  +1234567890  "}"#;
        let msg: IncomingMessage = serde_json::from_str(json).expect("Should deserialize");

        match msg {
            IncomingMessage::SIPTransfer { transfer_to } => {
                assert_eq!(transfer_to, "  +1234567890  ");
            }
            _ => panic!("Expected SIPTransfer variant"),
        }
    }

    #[test]
    fn test_sip_transfer_error_serialization() {
        let error = OutgoingMessage::SIPTransferError {
            message: "Invalid phone number".to_string(),
        };

        let json = serde_json::to_string(&error).expect("Should serialize");
        assert!(json.contains(r#""type":"sip_transfer_error""#));
        assert!(json.contains(r#""message":"Invalid phone number""#));
    }

    // ============== Message Size Validation Tests ==============

    #[test]
    fn test_speak_text_within_limit() {
        let text = "a".repeat(MAX_SPEAK_TEXT_SIZE);
        let msg = IncomingMessage::Speak {
            text,
            flush: None,
            allow_interruption: None,
        };
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_speak_text_exceeds_limit() {
        let text = "a".repeat(MAX_SPEAK_TEXT_SIZE + 1);
        let msg = IncomingMessage::Speak {
            text,
            flush: None,
            allow_interruption: None,
        };
        let err = msg.validate_size().unwrap_err();
        match err {
            MessageValidationError::SpeakTextTooLarge { size, max } => {
                assert_eq!(size, MAX_SPEAK_TEXT_SIZE + 1);
                assert_eq!(max, MAX_SPEAK_TEXT_SIZE);
            }
            _ => panic!("Expected SpeakTextTooLarge error"),
        }
    }

    #[test]
    fn test_send_message_within_limit() {
        let message = "b".repeat(MAX_MESSAGE_CONTENT_SIZE);
        let msg = IncomingMessage::SendMessage {
            message,
            role: "user".to_string(),
            topic: None,
            debug: None,
        };
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_send_message_exceeds_limit() {
        let message = "b".repeat(MAX_MESSAGE_CONTENT_SIZE + 1);
        let msg = IncomingMessage::SendMessage {
            message,
            role: "user".to_string(),
            topic: None,
            debug: None,
        };
        let err = msg.validate_size().unwrap_err();
        match err {
            MessageValidationError::MessageContentTooLarge { size, max } => {
                assert_eq!(size, MAX_MESSAGE_CONTENT_SIZE + 1);
                assert_eq!(max, MAX_MESSAGE_CONTENT_SIZE);
            }
            _ => panic!("Expected MessageContentTooLarge error"),
        }
    }

    #[test]
    fn test_sip_transfer_within_limit() {
        let transfer_to = "+".to_string() + &"1".repeat(MAX_SIP_TRANSFER_TO_SIZE - 1);
        let msg = IncomingMessage::SIPTransfer { transfer_to };
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_sip_transfer_exceeds_limit() {
        let transfer_to = "1".repeat(MAX_SIP_TRANSFER_TO_SIZE + 1);
        let msg = IncomingMessage::SIPTransfer { transfer_to };
        let err = msg.validate_size().unwrap_err();
        match err {
            MessageValidationError::SipTransferToTooLarge { size, max } => {
                assert_eq!(size, MAX_SIP_TRANSFER_TO_SIZE + 1);
                assert_eq!(max, MAX_SIP_TRANSFER_TO_SIZE);
            }
            _ => panic!("Expected SipTransferToTooLarge error"),
        }
    }

    #[test]
    fn test_config_message_validation_passes() {
        let msg = IncomingMessage::Config {
            stream_id: Some("test".to_string()),
            audio: Some(true),
            audio_disabled: None,
            stt_config: None,
            tts_config: None,
            livekit: None,
        };
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_clear_message_validation_passes() {
        let msg = IncomingMessage::Clear;
        assert!(msg.validate_size().is_ok());
    }

    #[test]
    fn test_validation_error_display() {
        let err = MessageValidationError::SpeakTextTooLarge {
            size: 150000,
            max: 102400,
        };
        let display = format!("{}", err);
        assert!(display.contains("150000"));
        assert!(display.contains("102400"));
        assert!(display.contains("Speak text too large"));
    }
}
